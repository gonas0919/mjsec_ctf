<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Volume Cannon</title>
  <style>
    html, body { margin:0; height:100%; background:#fff; overflow:hidden; font-family: system-ui, Arial; }
    #game { display:block; width:100vw; height:100vh; }

    #hud {
      position:fixed; left:24px; bottom:24px; user-select:none;
      display:flex; flex-direction:column; gap:10px;
    }
    #speaker { font-size:28px; line-height:1; }
    #labelRow { display:flex; align-items:baseline; gap:10px; }
    #labelRow b { font-size:20px; }
    #opBadge { font-size:20px; font-weight:700; }
    #expr { font-size:16px; opacity:.85; }

    #volBox {
      border:2px solid #333; width:200px; padding:12px 14px;
      display:flex; align-items:center; justify-content:space-between;
      font-weight:800; font-size:34px;
    }

    #hint {
      position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(255,255,255,0.92); color:#111;
      font-weight:700; font-size:18px;
    }
    #hint small { display:block; font-weight:500; margin-top:8px; opacity:.8; }

    /* ì„±ê³µ ì˜¤ë²„ë ˆì´(ì¶”ê°€) */
    #win {
      position:fixed; inset:0; display:none; place-items:center;
      background:rgba(255,255,255,0.92); color:#111;
      font-weight:800; font-size:18px;
      text-align:center;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="speaker">ğŸ”Š</div>
    <div id="labelRow">
      <b>volume:</b>
      <span id="opBadge">op: -</span>
    </div>
    <div id="goal" style="font-size:14px; opacity:.85;">ëª©í‘œ: volumeì„ 77ë¡œ ë§Œë“œì„¸ìš”</div>
    <div id="expr">last: (none)</div>
    <div id="volBox">
      <span id="volValue">100</span>
      <span id="opBig" style="font-size:28px; font-weight:900;">-</span>
    </div>
  </div>

  <div id="hint">
    <div style="text-align:center;">
      í´ë¦­í•˜ë©´ ì˜¤ë””ì˜¤/ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤.
      <small>ëª©í‘œ: volumeì„ 77ë¡œ ë§Œë“œì„¸ìš”</small>
    </div>
  </div>

  <div id="win">
    <div>
      Clear!<br/>
      ì ì‹œ í›„ íŒíŠ¸ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const volValueEl = document.getElementById('volValue');
  const opBadgeEl  = document.getElementById('opBadge');
  const opBigEl    = document.getElementById('opBig');
  const exprEl     = document.getElementById('expr');
  const hintEl     = document.getElementById('hint');
  const winEl      = document.getElementById('win'); // ì¶”ê°€

  const OPS = ['+', '-', 'Ã—', 'Ã·'];

  const state = {
    w: 0, h: 0,
    cross: { x: 0, y: 0 },
    volume: 100,
    selectedOp: '-',
    lastText: '(none)',
    tokens: [],
    cannon: { x: 80, y: 0, angle: -25 * Math.PI/180 },
    spawnRatePerSec: 10,
    opProbability: 0.25,
    maxTokens: 180,
    lastNow: performance.now(),
    spawnAcc: 0,
    audio: { ctx: null, gain: null, osc: null, started: false },

    won: false, // ì¶”ê°€
  };

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    state.w = canvas.width  = Math.floor(window.innerWidth * dpr);
    state.h = canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    state.cannon.y = window.innerHeight - 90;
  }
  window.addEventListener('resize', resize);
  resize();

  state.cross.x = window.innerWidth / 2;
  state.cross.y = window.innerHeight / 2;
  canvas.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    state.cross.x = e.clientX - r.left;
    state.cross.y = e.clientY - r.top;
  });

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function rand(a, b) { return a + Math.random() * (b - a); }

  async function win() {
    if (state.won) return;
    state.won = true;
    winEl.style.display = "grid";

    // ì„œë²„ì— ì™„ë£Œ ì•Œë¦¼
    const res = await fetch("/api/games/volume/complete", { method: "POST" });
    const data = await res.json().catch(() => ({}));
    if (res.ok && data.next) {
      setTimeout(() => { window.location.href = data.next; }, 700);
    } else {
      alert(data.error || "complete failed");
    }
  }

  function setVolume(v) {
    state.volume = clamp(Math.round(v), 0, 100);
    volValueEl.textContent = state.volume;
    if (state.audio.started && state.audio.gain) {
      state.audio.gain.gain.value = (state.volume / 100) * 0.25;
    }

    // ì¶”ê°€: ëª©í‘œê°’ ë„ë‹¬ ì‹œ ì„±ê³µ ì²˜ë¦¬
    if (state.volume === 77) {
      win();
    }
  }

  function setOp(op) {
    state.selectedOp = op;
    opBadgeEl.textContent = `op: ${op}`;
    opBigEl.textContent = op;
  }

  function applyOp(op, n) {
    const v = state.volume;
    let out = v;

    if (op === '+') out = v + n;
    else if (op === '-') out = v - n;
    else if (op === 'Ã—') out = v * n;
    else if (op === 'Ã·') out = (n === 0 ? v : v / n);

    state.lastText = `${v} ${op} ${n} = ${Math.round(out)}`;
    exprEl.textContent = `last: ${state.lastText}`;
    setVolume(out);
  }
    const OPSs = ['+', '-', 'Ã—', 'Ã·'];
    const MIN = 1;
    const MAX = 50;
  function makeToken() {
    const isOp = Math.random() < state.opProbability;
    const text = isOp
        ? OPSs[Math.floor(Math.random() * OPSs.length)]
        : String(MIN + Math.floor(Math.random() * (MAX - MIN + 1))); // 1~50

    const dx = state.cross.x - state.cannon.x;
    const dy = state.cross.y - state.cannon.y;
    const aimAngle = Math.atan2(dy, dx);
    const angle = aimAngle + rand(-0.15, 0.15);

    const speed = isOp ? rand(700, 820) : rand(420, 760);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    const size = isOp ? rand(34, 52) : rand(26, 42);
    const r = isOp ? 26 : 24;

    return {
      kind: isOp ? 'op' : 'num',
      text,
      x: state.cannon.x + Math.cos(angle) * 30,
      y: state.cannon.y + Math.sin(angle) * 30,
      vx, vy,
      r,
      size,
      born: performance.now(),
      ttl: rand(9000, 14000),
      spin: rand(-3, 3),
      rot: rand(-Math.PI, Math.PI),
    };
  }

  function spawnTokens(dt) {
    state.spawnAcc += dt * state.spawnRatePerSec;
    const count = Math.floor(state.spawnAcc);
    if (count <= 0) return;
    state.spawnAcc -= count;

    for (let i = 0; i < count; i++) {
      if (state.tokens.length >= state.maxTokens) break;
      state.tokens.push(makeToken());
    }
  }

  function updatePhysics(dt, now) {
    const g = 600;
    const floor = window.innerHeight - 40;
    const left = 0, right = window.innerWidth;

    for (const t of state.tokens) {
      t.vy += g * dt;
      t.x += t.vx * dt;
      t.y += t.vy * dt;
      t.rot += t.spin * dt;

      if (t.y > floor) {
        t.y = floor;
        t.vy *= -0.45;
        t.vx *= 0.85;
      }

      if (t.x < left + 20) { t.x = left + 20; t.vx *= -0.65; }
      if (t.x > right - 20){ t.x = right - 20; t.vx *= -0.65; }
    }

    state.tokens = state.tokens.filter(t => {
      if (now - t.born > t.ttl) return false;
      if (t.y > window.innerHeight + 300) return false;
      return true;
    });
  }

  function drawCannon() {
    const x = state.cannon.x, y = state.cannon.y;
    const dx = state.cross.x - x;
    const dy = state.cross.y - y;
    const angle = Math.atan2(dy, dx);

    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(0, 0, 22, 0, Math.PI * 2);
    ctx.fill();

    ctx.rotate(angle);
    ctx.fillRect(0, -8, 52, 16);
    ctx.restore();
  }

  function drawTokens() {
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (const t of state.tokens) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.rotate(t.rot);
      ctx.fillStyle = '#111';
      ctx.font = `800 ${t.size}px system-ui, Arial`;
      ctx.fillText(t.text, 0, 0);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawCrosshair() {
    const x = state.cross.x, y = state.cross.y;
    ctx.save();
    ctx.strokeStyle = '#cc3333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.moveTo(x - 16, y); ctx.lineTo(x - 6, y);
    ctx.moveTo(x + 6, y);  ctx.lineTo(x + 16, y);
    ctx.moveTo(x, y - 16); ctx.lineTo(x, y - 6);
    ctx.moveTo(x, y + 6);  ctx.lineTo(x, y + 16);
    ctx.stroke();
    ctx.restore();
  }

  function pickHitToken() {
    const cx = state.cross.x, cy = state.cross.y;
    let bestIdx = -1;
    let bestD = Infinity;

    for (let i = 0; i < state.tokens.length; i++) {
      const t = state.tokens[i];
      const d = Math.hypot(t.x - cx, t.y - cy);
      if (d < t.r + 10 && d < bestD) {
        bestD = d;
        bestIdx = i;
      }
    }
    if (bestIdx === -1) return null;
    return state.tokens.splice(bestIdx, 1)[0];
  }

  function shoot() {
    const hit = pickHitToken();
    if (!hit) return;

    if (hit.kind === 'op') {
      setOp(hit.text);
      state.lastText = `op set -> ${hit.text}`;
      exprEl.textContent = `last: ${state.lastText}`;
    } else {
      applyOp(state.selectedOp, Number(hit.text));
    }
  }

  function startAudio() {
    if (state.audio.started) return;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) { alert('ì´ ë¸Œë¼ìš°ì €ëŠ” Web Audio APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.'); return; }

    const ac = new AudioCtx();
    const gain = ac.createGain();
    const osc = ac.createOscillator();

    osc.type = 'sine';
    osc.frequency.value = 220;

    gain.gain.value = (state.volume / 100) * 0.25;
    osc.connect(gain).connect(ac.destination);
    osc.start();

    state.audio = { ctx: ac, gain, osc, started: true };
    hintEl.style.display = 'none';
  }

  hintEl.addEventListener('click', startAudio);

  canvas.addEventListener('mousedown', () => {
    if (!state.audio.started) return;
    shoot();
  });

  window.addEventListener('keydown', (e) => {
    if (!state.audio.started) return;
    if (e.code === 'Space') { e.preventDefault(); shoot(); }
  });

  function frame(now) {
    const dt = Math.min(0.033, (now - state.lastNow) / 1000);
    state.lastNow = now;

    spawnTokens(dt);
    updatePhysics(dt, now);

    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    drawCannon();
    drawTokens();
    drawCrosshair();

    requestAnimationFrame(frame);
  }

  setVolume(100);
  setOp('-');
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
